import SwiftSyntax
import Intentions
import SwiftAST

extension SwiftSyntaxProducer {
    // TODO: Consider reducing code duplication within `generateStatement` and
    // `_generateStatements`
    
    /// Generates a code block for the given statement.
    /// This code block might have zero, one or more sub-statements, depending on
    /// the properties of the given statement, e.g. expression statements which
    /// feature zero elements in the expressions array result in an empty code block.
    ///
    /// This method is provided more as an inspection of generation of syntax
    /// elements for particular statements, and is not used internally by the
    /// syntax producer while generating whole files.
    ///
    /// - Returns: A code block containing the statements generated by the statement
    /// provided.
    public func generateStatement(_ statement: Statement) -> CodeBlockSyntax {
        if let statement = statement as? CompoundStatement {
            return generateCompound(statement)
        }
        
        return CodeBlockSyntax { builder in
            indent()
            defer {
                deindent()
            }
            
            let stmts = generateStatementBlockItems(statement)
            
            for (i, stmt) in stmts.enumerated() {
                if i > 0 {
                    addExtraLeading(.newlines(1))
                }
                
                builder.addStatement(stmt())
            }
        }
    }
    
    func generateCompound(_ compoundStmt: CompoundStatement) -> CodeBlockSyntax {
        CodeBlockSyntax { builder in
            builder.useLeftBrace(SyntaxFactory.makeLeftBraceToken().withLeadingSpace())
            
            indent()
            defer {
                deindent()
                builder.useRightBrace(SyntaxFactory
                    .makeRightBraceToken()
                    .onNewline()
                    .addingLeadingTrivia(indentation()))
                extraLeading = nil
            }
            
            let stmts = _generateStatements(compoundStmt.statements)
            
            for stmt in stmts {
                builder.addStatement(stmt)
            }
        }
    }
    
    func _generateStatements(_ stmtList: [Statement]) -> [CodeBlockItemSyntax] {
        var items: [CodeBlockItemSyntax] = []
        
        for (i, stmt) in stmtList.enumerated() {
            let stmtSyntax = generateStatementBlockItems(stmt)
            
            for item in stmtSyntax {
                addExtraLeading(.newlines(1) + indentation())
                items.append(item())
            }
            
            if i < stmtList.count - 1 && _shouldEmitNewlineSpacing(between: stmt, stmt2: stmtList[i + 1]) {
                addExtraLeading(.newlines(1))
            }
        }
        
        return items
    }
    
    private func _shouldEmitNewlineSpacing(between stmt1: Statement, stmt2: Statement) -> Bool {
        switch (stmt1, stmt2) {
        case (is ExpressionsStatement, is ExpressionsStatement):
            return false
        case (is VariableDeclarationsStatement, is ExpressionsStatement),
             (is VariableDeclarationsStatement, is VariableDeclarationsStatement):
            return false
            
        default:
            return true
        }
    }
    
    func generateStatementBlockItems(_ stmt: Statement) -> [() -> CodeBlockItemSyntax] {
        for comment in stmt.comments {
            addExtraLeading(.newlines(1) + indentation())
            
            // TODO: Perhaps Statement.comments should be an enum describing these
            // cases, instead of relegating this detection to here?
            if comment.hasPrefix("//") {
                addExtraLeading(.lineComment(comment))
            } else if comment.hasPrefix("///") {
                addExtraLeading(.docLineComment(comment))
            } else if comment.hasPrefix("/*") {
                addExtraLeading(.blockComment(comment))
            } else if comment.hasPrefix("/**") {
                addExtraLeading(.docBlockComment(comment))
            } else {
                addExtraLeading(.lineComment(comment))
            }
        }
        
        if let label = stmt.label, !isLabelableStatementType(stmt) {
            if !stmt.comments.isEmpty {
                addExtraLeading(.newlines(1) + indentation())
            }
            
            addExtraLeading(.lineComment("// \(label):"))
            
            if stmt.comments.isEmpty {
                addExtraLeading(.newlines(1) + indentation())
            }
        }
        
        let genList: [() -> CodeBlockItemSyntax]
        
        switch stmt {
        case let stmt as ReturnStatement:
            genList = [{ self.generateReturn(stmt).inCodeBlock() }]
            
        case let stmt as ContinueStatement:
            genList = [{ self.generateContinue(stmt).inCodeBlock() }]
            
        case let stmt as BreakStatement:
            genList = [{ self.generateBreak(stmt).inCodeBlock() }]
            
        case let stmt as FallthroughStatement:
            genList = [{ self.generateFallthrough(stmt).inCodeBlock() }]
            
        case let stmt as ExpressionsStatement:
            genList = generateExpressions(stmt)
            
        case let stmt as VariableDeclarationsStatement:
            genList = generateVariableDeclarations(stmt)
            
        case let stmt as IfStatement:
            genList = [{ self.generateIfStmt(stmt).inCodeBlock() }]
            
        case let stmt as SwitchStatement:
            genList = [{ self.generateSwitchStmt(stmt).inCodeBlock() }]
            
        case let stmt as WhileStatement:
            genList = [{ self.generateWhileStmt(stmt).inCodeBlock() }]
            
        case let stmt as DoStatement:
            genList = [{ self.generateDo(stmt).inCodeBlock() }]
            
        case let stmt as DoWhileStatement:
            genList = [{ self.generateDoWhileStmt(stmt).inCodeBlock() }]
            
        case let stmt as ForStatement:
            genList = [{ self.generateForIn(stmt).inCodeBlock() }]
            
        case let stmt as DeferStatement:
            genList = [{ self.generateDefer(stmt).inCodeBlock() }]
            
        case let stmt as CompoundStatement:
            genList = stmt.statements.flatMap(generateStatementBlockItems)
            
        case let stmt as UnknownStatement:
            genList = [{ self.generateUnknown(stmt).inCodeBlock() }]
            
        default:
            genList = [{ SyntaxFactory.makeBlankExpressionStmt().inCodeBlock() }]
        }
        
        return applyingTrailingComment(comment: stmt.trailingComment,
                                       toList: genList)
    }
    
    private func applyingTrailingComment(
        comment: String?,
        toList list: [() -> CodeBlockItemSyntax]) -> [() -> CodeBlockItemSyntax] {
        
        guard let comment = comment, let last = list.last else {
            return list
        }
        
        var list = list
        
        list[list.count - 1] = {
            return last().withTrailingTrivia(.spaces(1) + .lineComment(comment))
        }
        
        return list
    }
    
    // TODO: This should be a property inside the Statement class
    private func isLabelableStatementType(_ stmt: Statement) -> Bool {
        switch stmt {
        case is IfStatement, is SwitchStatement, is DoStatement, is ForStatement,
             is WhileStatement, is DoWhileStatement:
            return true
            
        default:
            return false
        }
    }
    
    func generateExpressions(_ stmt: ExpressionsStatement) -> [() -> CodeBlockItemSyntax] {
        stmt.expressions
            .map { exp -> () -> CodeBlockItemSyntax in
                return {
                    if self.settings.outputExpressionTypes {
                        self.addExtraLeading(Trivia.lineComment("// type: \(exp.resolvedType ?? "<nil>")"))
                        self.addExtraLeading(.newlines(1))
                        self.addExtraLeading(self.indentation())
                    }
                    
                    return self.generateExpression(exp).inCodeBlock()
                }
            }
    }
    
    func generateVariableDeclarations(_ stmt: VariableDeclarationsStatement) -> [() -> CodeBlockItemSyntax] {
        if stmt.decl.isEmpty {
            return []
        }
        
        return varDeclGenerator
            .generateVariableDeclarations(stmt)
            .enumerated()
            .map { (i, decl) in
                return {
                    if self.settings.outputExpressionTypes {
                        self.addExtraLeading(Trivia.lineComment("// decl type: \(stmt.decl[i].type)"))
                        self.addExtraLeading(.newlines(1))
                        self.addExtraLeading(self.indentation())

                        if let exp = stmt.decl[i].initialization {
                            self.addExtraLeading(Trivia.lineComment("// init type: \(exp.resolvedType ?? "<nil>")"))
                            self.addExtraLeading(.newlines(1))
                            self.addExtraLeading(self.indentation())
                        }
                    }

                    return SyntaxFactory.makeCodeBlockItem(item: decl().asSyntax,
                                                           semicolon: nil,
                                                           errorTokens: nil)
                }
            }
    }
    
    func generateReturn(_ stmt: ReturnStatement) -> ReturnStmtSyntax {
        ReturnStmtSyntax { builder in
            var returnToken = makeStartToken(SyntaxFactory.makeReturnKeyword)
            
            if let exp = stmt.exp {
                returnToken = returnToken.addingTrailingSpace()
                builder.useExpression(generateExpression(exp))
            }
            
            builder.useReturnKeyword(returnToken)
        }
    }
    
    func generateContinue(_ stmt: ContinueStatement) -> ContinueStmtSyntax {
        ContinueStmtSyntax { builder in
            builder.useContinueKeyword(makeStartToken(SyntaxFactory.makeContinueKeyword))
            
            if let label = stmt.targetLabel {
                builder.useLabel(makeIdentifier(label).withLeadingSpace())
            }
        }
    }
    
    func generateBreak(_ stmt: BreakStatement) -> BreakStmtSyntax {
        BreakStmtSyntax { builder in
            builder.useBreakKeyword(makeStartToken(SyntaxFactory.makeBreakKeyword))
            
            if let label = stmt.targetLabel {
                builder.useLabel(makeIdentifier(label).withLeadingSpace())
            }
        }
    }
    
    func generateFallthrough(_ stmt: FallthroughStatement) -> FallthroughStmtSyntax {
        FallthroughStmtSyntax { builder in
            builder.useFallthroughKeyword(makeStartToken(SyntaxFactory.makeFallthroughKeyword))
        }
    }
    
    func generateIfStmt(_ stmt: IfStatement) -> IfStmtSyntax {
        IfStmtSyntax { builder in
            if let label = stmt.label {
                builder.useLabelName(prepareStartToken(SyntaxFactory.makeIdentifier(label)))
                builder.useLabelColon(SyntaxFactory.makeColonToken())
                addExtraLeading(.newlines(1) + indentation())
            }
            
            builder.useIfKeyword(makeStartToken(SyntaxFactory.makeIfKeyword).withTrailingSpace())
            
            if let pattern = stmt.pattern {
                builder.addCondition(ConditionElementSyntax { builder in
                    builder.useCondition(OptionalBindingConditionSyntax { builder in
                        builder.useLetOrVarKeyword(SyntaxFactory.makeLetKeyword().withTrailingSpace())
                        
                        builder.usePattern(generatePattern(pattern))
                        
                        builder.useInitializer(InitializerClauseSyntax { builder in
                            builder.useEqual(SyntaxFactory.makeEqualToken().withTrailingSpace().withLeadingSpace())
                            builder.useValue(generateExpression(stmt.exp))
                        })
                    }.asSyntax)
                })
            } else {
                builder.addCondition(ConditionElementSyntax { builder in
                    builder.useCondition(generateExpression(stmt.exp).asSyntax)
                })
            }
            
            builder.useBody(generateCompound(stmt.body))
            
            if let _else = stmt.elseBody {
                builder.useElseKeyword(makeStartToken(SyntaxFactory.makeElseKeyword).addingLeadingSpace())
                if _else.statements.count == 1, let elseIfStmt = _else.statements[0] as? IfStatement {
                    addExtraLeading(.spaces(1))
                    builder.useElseBody(generateIfStmt(elseIfStmt).asSyntax)
                } else {
                    builder.useElseBody(generateCompound(_else).asSyntax)
                }
            }
        }
    }
    
    func generateSwitchStmt(_ stmt: SwitchStatement) -> SwitchStmtSyntax {
        SwitchStmtSyntax { builder in
            if let label = stmt.label {
                builder.useLabelName(prepareStartToken(SyntaxFactory.makeIdentifier(label)))
                builder.useLabelColon(SyntaxFactory.makeColonToken())
                addExtraLeading(.newlines(1) + indentation())
            }
            
            builder.useSwitchKeyword(makeStartToken(SyntaxFactory.makeSwitchKeyword).withTrailingSpace())
            builder.useLeftBrace(SyntaxFactory.makeLeftBraceToken().withLeadingSpace())
            builder.useRightBrace(SyntaxFactory.makeRightBraceToken().withLeadingTrivia(.newlines(1) + indentation()))
            builder.useExpression(generateExpression(stmt.exp))
            
            var syntaxes: [Syntax] = []
            
            for _case in stmt.cases {
                addExtraLeading(.newlines(1) + indentation())
                
                let label = generateSwitchCaseLabel(_case).asSyntax
                syntaxes.append(generateSwitchCase(label, statements: _case.statements).asSyntax)
            }
            
            if let _default = stmt.defaultCase {
                addExtraLeading(.newlines(1) + indentation())
                
                let label = SwitchDefaultLabelSyntax { builder in
                    builder.useDefaultKeyword(makeStartToken(SyntaxFactory.makeDefaultKeyword))
                    builder.useColon(SyntaxFactory.makeColonToken())
                }.asSyntax
                syntaxes.append(generateSwitchCase(label, statements: _default).asSyntax)
            }
            
            builder.addCase(SyntaxFactory.makeSwitchCaseList(syntaxes).asSyntax)
        }
    }
    
    func generateSwitchCase(_ caseLabel: Syntax, statements: [Statement]) -> SwitchCaseSyntax {
        SwitchCaseSyntax { builder in
            builder.useLabel(caseLabel)
            
            indent()
            defer {
                deindent()
            }
            
            let stmts = _generateStatements(statements)
            
            for stmt in stmts {
                builder.addStatement(stmt)
            }
        }
    }
    
    func generateSwitchCaseLabel(_ _case: SwitchCase) -> SwitchCaseLabelSyntax {
        SwitchCaseLabelSyntax { builder in
            builder.useCaseKeyword(makeStartToken(SyntaxFactory.makeCaseKeyword).withTrailingSpace())
            builder.useColon(SyntaxFactory.makeColonToken())
            
            iterateWithComma(_case.patterns) { (item, hasComma) in
                builder.addCaseItem(CaseItemSyntax { builder in
                    builder.usePattern(generatePattern(item))
                    
                    if hasComma {
                        builder.useTrailingComma(SyntaxFactory.makeCommaToken().withTrailingSpace())
                    }
                })
            }
        }
    }
    
    func generateWhileStmt(_ stmt: WhileStatement) -> WhileStmtSyntax {
        WhileStmtSyntax { builder in
            if let label = stmt.label {
                builder.useLabelName(prepareStartToken(SyntaxFactory.makeIdentifier(label)))
                builder.useLabelColon(SyntaxFactory.makeColonToken())
                addExtraLeading(.newlines(1) + indentation())
            }
            
            builder.useWhileKeyword(makeStartToken(SyntaxFactory.makeWhileKeyword).withTrailingSpace())
            
            builder.addCondition(ConditionElementSyntax { builder in
                builder.useCondition(generateExpression(stmt.exp).asSyntax)
            })
            
            builder.useBody(generateCompound(stmt.body))
        }
    }
    
    func generateDoWhileStmt(_ stmt: DoWhileStatement) -> RepeatWhileStmtSyntax {
        RepeatWhileStmtSyntax { builder in
            if let label = stmt.label {
                builder.useLabelName(prepareStartToken(SyntaxFactory.makeIdentifier(label)))
                builder.useLabelColon(SyntaxFactory.makeColonToken())
                addExtraLeading(.newlines(1) + indentation())
            }
            
            builder.useRepeatKeyword(makeStartToken(SyntaxFactory.makeRepeatKeyword))
            builder.useWhileKeyword(SyntaxFactory.makeWhileKeyword().addingSurroundingSpaces())
            
            builder.useBody(generateCompound(stmt.body))
            builder.useCondition(generateExpression(stmt.exp))
        }
    }
    
    func generateForIn(_ stmt: ForStatement) -> ForInStmtSyntax {
        ForInStmtSyntax { builder in
            if let label = stmt.label {
                builder.useLabelName(prepareStartToken(SyntaxFactory.makeIdentifier(label)))
                builder.useLabelColon(SyntaxFactory.makeColonToken())
                addExtraLeading(.newlines(1) + indentation())
            }
            
            builder.useForKeyword(makeStartToken(SyntaxFactory.makeForKeyword).withTrailingSpace())
            builder.useInKeyword(SyntaxFactory.makeInKeyword().addingSurroundingSpaces())
            builder.useBody(generateCompound(stmt.body))
            builder.usePattern(generatePattern(stmt.pattern))
            builder.useSequenceExpr(generateExpression(stmt.exp))
        }
    }
    
    func generateDo(_ stmt: DoStatement) -> DoStmtSyntax {
        DoStmtSyntax { builder in
            if let label = stmt.label {
                builder.useLabelName(prepareStartToken(SyntaxFactory.makeIdentifier(label)))
                builder.useLabelColon(SyntaxFactory.makeColonToken())
                addExtraLeading(.newlines(1) + indentation())
            }
            
            builder.useDoKeyword(makeStartToken(SyntaxFactory.makeDoKeyword))
            builder.useBody(generateCompound(stmt.body))
        }
    }
    
    func generateDefer(_ stmt: DeferStatement) -> DeferStmtSyntax {
        DeferStmtSyntax { builder in
            builder.useDeferKeyword(makeStartToken(SyntaxFactory.makeDeferKeyword))
            builder.useBody(generateCompound(stmt.body))
        }
    }
    
    func generateUnknown(_ unknown: UnknownStatement) -> ExprSyntax {
        var trivia = extraLeading ?? []
        let indent = indentationString()
        
        trivia = trivia + Trivia.blockComment("""
            /*
            \(indent)\(unknown.context.description)
            \(indent)*/
            """)
        
        return SyntaxFactory
            .makeBlankIdentifierExpr()
            .withIdentifier(makeIdentifier("").withLeadingTrivia(trivia))
            .asExprSyntax
    }
    
    func generatePattern(_ pattern: Pattern) -> PatternSyntax {
        switch pattern {
        case .identifier(let ident):
            return IdentifierPatternSyntax { $0.useIdentifier(makeIdentifier(ident)) }.asPatternSyntax
            
        case .expression(let exp):
            return ExpressionPatternSyntax { $0.useExpression(generateExpression(exp)) }.asPatternSyntax
            
        case .tuple(let items):
            return TuplePatternSyntax { builder in
                builder.useLeftParen(SyntaxFactory.makeLeftParenToken())
                builder.useRightParen(SyntaxFactory.makeRightParenToken())
                
                iterateWithComma(items) { (item, hasComma) in
                    builder.addElement(
                        TuplePatternElementSyntax { builder in
                            builder.usePattern(generatePattern(item))
                            
                            if hasComma {
                                builder.useTrailingComma(SyntaxFactory
                                    .makeCommaToken()
                                    .withTrailingSpace())
                            }
                        }
                    )
                }
            }.asPatternSyntax
        }
    }
}

private extension ExprSyntaxProtocol {
    func inCodeBlock() -> CodeBlockItemSyntax {
        CodeBlockItemSyntax { $0.useItem(self.asSyntax) }
    }
}

private extension StmtSyntaxProtocol {
    func inCodeBlock() -> CodeBlockItemSyntax {
        CodeBlockItemSyntax { $0.useItem(self.asSyntax) }
    }
}
